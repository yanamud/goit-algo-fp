**ОПИС ЗАВДАНЬ:**


**Завдвння 1: Структури даних. Сортування. Робота з однозв'язним списком**

Для прикладу створено зв'язний список 'list_1': [10, 7, 5, 18, 9, 15]

  - реалізовано реверсований зв'язний список 'list_1': [15, 9, 18, 5, 7, 10]

  - реалізовано сортування зв'язного списку 'list_1' вставками: [5, 7, 9, 10, 15, 18]

Для прикладу створено зв'язний список 'list_2': [11, 17, 14, 1, 8, 4]

  - реалізовано сортування зв'язного списку 'list_2': [1, 4, 8, 11, 14, 17]

  - реалізовано злиття зв'язних списків 'list_1' та 'list_2':  [1, 4, 5, 7, 8, 9, 10, 11, 14, 15, 17, 18]


**Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії**

Написана програма з використанням рекурсії для створення фрактала “дерево Піфагора”.

Є можливість вказати рівень рекурсії.

![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/4b5c2920-1e4d-424d-8e7f-dfde5bea93b2)


**Завдання 3. Дерева, алгоритм Дейкстри**

- Створено зважений граф
- Використано бінарну купу (піраміду) для оптимізації вибору вершин
- Обчислено найкоротші шляхи від початкової вершини до всіх інших.

![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/91c2419c-85ca-4e01-99e8-1263064dce18)

Найкоротший шляхи від початкового вузла до всіх інших вузлів (перелік вузлів)

R1 | ['R1']

R2 | ['R1', 'R2']

R3 | ['R1', 'R3']

R4 | ['R1', 'R4']

R8 | ['R1', 'R2', 'R8']

R6 | ['R1', 'R3', 'R6']

R7 | ['R1', 'R3', 'R7']

R5 | ['R1', 'R4', 'R5']

R9 | ['R1', 'R2', 'R8', 'R9']

R11 | ['R1', 'R3', 'R6', 'R11'] 

R10 | ['R1', 'R3', 'R7', 'R10'] 

R12 | ['R1', 'R4', 'R5', 'R12']   

R16 | ['R1', 'R2', 'R8', 'R9', 'R16'] 

R14 | ['R1', 'R3', 'R6', 'R11', 'R14']

R15 | ['R1', 'R3', 'R7', 'R10', 'R15']

R13 | ['R1', 'R4', 'R5', 'R12', 'R13']

R17 | ['R1', 'R2', 'R8', 'R9', 'R16', 'R17']

R18 | ['R1', 'R3', 'R6', 'R11', 'R14', 'R18']

R19 | ['R1', 'R4', 'R5', 'R12', 'R13', 'R19']

R20 | ['R1', 'R2', 'R8', 'R9', 'R16', 'R17', 'R20']

Довжина найкоротшого шляху від початкового вузла до всіх інших вузлів (кількість вузлів)

{'R1': 0, 'R2': 1, 'R3': 1, 'R4': 1, 'R8': 2, 'R6': 2, 'R7': 2, 'R5': 2, 'R9': 3, 'R11': 3, 'R10': 3, 'R12': 3, 'R16': 4, 'R14': 4, 'R15': 4, 'R13': 4, 'R17': 5, 'R18': 5, 'R19': 5, 'R20': 6}

Довжина найкоротшого шляху від початкового вузла до всіх інших вузлів (сума всіх ваг вузлів)

{'R1': 0, 'R2': 4, 'R3': 3, 'R4': 6, 'R5': 12, 'R6': 6, 'R7': 6, 'R8': 8, 'R9': 11, 'R10': 9, 'R11': 9, 'R12': 12, 'R13': 17, 'R14': 12, 'R15': 12, 'R16': 14, 'R17': 16, 'R18': 15, 'R19': 19, 'R20': 18}


**Завдання 4. Візуалізація піраміди**

- Виконано побудову бінарного дерева
- Реалізовано функцію, що перетворює дерево на бінарну купу та її візуалізує
  
![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/68a64a36-476c-456b-a870-4b42f3b5dd49)

![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/f3e75a9a-f944-4c7d-9c59-d08cca14b7cd)

![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/87e1a3f3-d724-4583-ac59-0c84f2cd6fea)


**Завдання 5. Візуалізація обходу бінарного дерева**

Створено програму, яка візуалізує обходи дерева. Кольори вузлів змінюються від темних до світлих відтінків, 
залежно від послідовності обходу. Кожен вузол при його відвідуванні отримує унікальний колір, який візуально 
відображає порядок обходу. 

- **у глибину**
  
![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/95d57b3a-8592-4ac0-b926-6c3e19ed2d22)

- **в ширину**
  
![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/08a6a5b1-67c3-4925-824a-b4b7c9d0661a)

  
**Завдання 6: Жадібні алгоритми та динамічне програмування**

Представлено дані про їжу у вигляді словника, де ключ — назва страви, а значення — це словник з вартістю та калорійністю.

items = {

    "pizza": {"cost": 50, "calories": 300},
    
    "hamburger": {"cost": 40, "calories": 250},
    
    "hot-dog": {"cost": 30, "calories": 200},
    
    "pepsi": {"cost": 10, "calories": 100},
    
    "cola": {"cost": 15, "calories": 220},
    
    "potato": {"cost": 25, "calories": 350}
    
}

- Розроблено функцію **greedy_algorithm** жадібного алгоритму, яка вибирає страви, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.

  В результаті отримано:

    - Згідно наданого бюджету в розмірі 105 з урахуванням максимізації співвідношення калорій до вартості можна придбати:
    
      ['pizza', 'hamburger', 'pepsi']
    
    - Загальна вартість придбаного кошику:
      100
    
    - Загальна калорійність придбаного кошику:
      650
    
    - Залишок бюджету:
      5

- Розроблено функцію **dynamic_programming** алгоритму динамічного програмування, яка обчислює оптимальний набір страв для максимізації калорійності при заданому бюджеті.

  В результаті отримано:

    - Згідно наданого бюджету в розмірі 105 з урахуванням максимізації калорійності можна придбати:
      
      ['potato', 'cola', 'pepsi', 'pizza']
    
    - Загальна вартість придбаного кошику:
      100
    
    - Загальна калорійність придбаного кошику:
      970
    
    - Залишок бюджету:
      5


**Завдання 7: Використання методу Монте-Карло**
- Написано програму, яка:
    - імітує велику кількість кидків кубиків (в прикладі використано 1_000_000 кидків)
    - обчислює суми чисел, які випадають на кубиках,
    - визначає ймовірність кожної можливої суми.

- Сворено таблицю та графік, які відображають ймовірності кожної можливої суми, розраховані за допомогою методу Монте-Карло.

- Порівняно отримані результати з аналітичними розрахунками (наведено в таблиці)

  ![image](https://github.com/yanamud/goit-algo-fp/assets/136761283/8b14d71b-ac3b-4138-9fc5-2c3b9c337444)


Dice  | Prob-actual | Prob-teor | Diff-ty 
------|-------------|-----------|-------- 
 2    | 2.81%       | 2.78%     | 0.03%   
 3    | 5.53%       | 5.56%     | -0.03%  
 4    | 8.30%       | 8.33%     | -0.03%  
 5    | 11.14%      | 11.11%    | 0.03% 
 6    | 13.90%      | 13.89%    | 0.01% 
 7    | 16.67%      | 16.67%    | 0.00% 
 8    | 13.92%      | 13.89%    | 0.03% 
 9    | 11.08%      | 11.11%    | -0.03%
 10   | 8.36%       | 8.33%     | 0.03%   
 11   | 5.52%       | 5.56%     | -0.04%  
 12   | 2.76%       | 2.78%     | -0.02%  

З отриманих результатів можна зробити висновки, що ймовірність отримання кожної можливої суми при підкиданні двох кубиків, 
обчислена методом Монте-Карло, досить близька до наданих аналітичних даних.

Також з графіку видно, що ймовірність отримання кожної можливої суми рівномірно розподілена.

Отже, метод Монте-Карло демонструє свою універсальність та ефективність у розв’язанні завдань, де точні аналітичні розрахунки можуть бути складними або неможливими.
У наведеному прикладі використання методу Монте-Карло для обчислення ймовірності отримання кожної можливої суми при підкиданні двох кубиків показало, що при достатньо 
великій кількості випадкових підкидань кубиків результати наближаються до аналітичних розрахунків.

Це підтверджує факт, що метод Монте-Карло може бути досить точним при правильному застосуванні, хоча він і базується на статистичному випадковому відборі.


